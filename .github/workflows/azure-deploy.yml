name: Build and deploy Node.js app to Azure Web App - videofactory

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read #This is required for actions/checkout

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js version
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install ffmpeg for build process
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
          
          # Create scripts directory
          mkdir -p scripts
          
          # Create ffmpeg installation script that will be included in the deployment
          cat > scripts/install-ffmpeg.sh << 'EOL'
          #!/bin/bash
          # TDNM App ffmpeg installation and verification script
          # This script installs ffmpeg and verifies it's working correctly
          # Compatible with both Azure and Render.com environments
          
          set -e
          
          echo "=== TDNM App ffmpeg Installation ==="
          echo "Starting installation at $(date)"
          echo "Running as user: $(whoami)"
          echo "Current directory: $(pwd)"
          echo "System information: $(uname -a)"
          
          # Detect environment
          if [ -n "$WEBSITE_SITE_NAME" ]; then
            ENVIRONMENT="Azure"
          elif [ -n "$RENDER" ]; then
            ENVIRONMENT="Render"
          else
            ENVIRONMENT="Unknown"
          fi
          
          echo "Detected environment: $ENVIRONMENT"
          
          # Function to check if a command exists
          command_exists() {
            command -v "$1" >/dev/null 2>&1
          }
          
          # Function to install ffmpeg based on the detected environment
          install_ffmpeg() {
            echo "Installing ffmpeg..."
            
            if [ "$ENVIRONMENT" = "Azure" ]; then
              # Azure Web App (Ubuntu-based)
              echo "Installing ffmpeg on Azure (Ubuntu)..."
              apt-get update -y
              apt-get install -y ffmpeg
            elif [ "$ENVIRONMENT" = "Render" ]; then
              # Render.com
              echo "Installing ffmpeg on Render..."
              apt-get update -y
              apt-get install -y ffmpeg
            else
              # Try to detect the package manager and install
              if command_exists apt-get; then
                echo "Detected apt-get, installing ffmpeg..."
                apt-get update -y
                apt-get install -y ffmpeg
              elif command_exists apk; then
                echo "Detected apk (Alpine Linux), installing ffmpeg..."
                apk update
                apk add --no-cache ffmpeg
              elif command_exists yum; then
                echo "Detected yum, installing ffmpeg..."
                yum -y install epel-release
                yum -y install ffmpeg ffmpeg-devel
              else
                echo "ERROR: Could not detect package manager. Please install ffmpeg manually."
                exit 1
              fi
            fi
          }
          
          # Function to verify ffmpeg installation
          verify_ffmpeg() {
            echo "Verifying ffmpeg installation..."
            
            if command_exists ffmpeg; then
              FFMPEG_VERSION=$(ffmpeg -version | head -n 1)
              echo "✅ ffmpeg is installed: $FFMPEG_VERSION"
              echo "ffmpeg location: $(which ffmpeg)"
              
              # Create a test file to verify functionality
              echo "Testing ffmpeg functionality..."
              
              # Create a temporary directory
              TMP_DIR=$(mktemp -d)
              TEST_IMAGE="$TMP_DIR/test.png"
              TEST_AUDIO="$TMP_DIR/test.mp3"
              TEST_OUTPUT="$TMP_DIR/test.mp4"
              
              # Create a simple 100x100 black image (base64 encoded PNG)
              echo "Creating test image..."
              echo "iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABLSURBVHhe7cExAQAAAMKg9U9tCU8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbjUAzAABOe9PEwAAAABJRU5ErkJggg==" | base64 -d > "$TEST_IMAGE"
              
              # Create a simple silent audio file (1 second)
              echo "Creating test audio..."
              ffmpeg -f lavfi -i anullsrc=r=44100:cl=mono -t 1 -q:a 9 -acodec libmp3lame "$TEST_AUDIO" -y >/dev/null 2>&1
              
              # Combine them into a video
              echo "Creating test video..."
              ffmpeg -loop 1 -i "$TEST_IMAGE" -i "$TEST_AUDIO" -c:v libx264 -c:a aac -shortest "$TEST_OUTPUT" -y >/dev/null 2>&1
              
              # Check if output file exists
              if [ -f "$TEST_OUTPUT" ]; then
                echo "✅ ffmpeg functionality test passed!"
                
                # Get file info
                echo "Test video details:"
                ffmpeg -i "$TEST_OUTPUT" 2>&1 | grep -E 'Duration|Stream'
              else
                echo "❌ ffmpeg functionality test failed: Could not create test video"
                exit 1
              fi
              
              # Clean up
              rm -rf "$TMP_DIR"
            else
              echo "❌ ffmpeg is not installed or not in PATH"
              exit 1
            fi
          }
          
          # Function to create necessary directories
          create_directories() {
            echo "Creating necessary directories..."
            
            # List of directories to create
            DIRS=(
              "public/generated-audios"
              "public/generated-images"
              "public/generated-videos"
              "tmp"
            )
            
            for DIR in "${DIRS[@]}"; do
              if [ ! -d "$DIR" ]; then
                echo "Creating directory: $DIR"
                mkdir -p "$DIR"
                
                # Set permissions
                chmod 755 "$DIR"
              else
                echo "Directory already exists: $DIR"
              fi
            done
            
            echo "✅ Directories created and permissions set"
          }
          
          # Main execution
          echo "Starting ffmpeg setup..."
          
          # Check if ffmpeg is already installed
          if command_exists ffmpeg; then
            echo "ffmpeg is already installed, skipping installation"
            FFMPEG_VERSION=$(ffmpeg -version | head -n 1)
            echo "Current version: $FFMPEG_VERSION"
          else
            echo "ffmpeg not found, installing..."
            install_ffmpeg
          fi
          
          # Verify the installation
          verify_ffmpeg
          
          # Create necessary directories
          create_directories
          
          echo "=== ffmpeg setup completed successfully ==="
          echo "Installation completed at $(date)"
          EOL
          
          chmod +x scripts/install-ffmpeg.sh

      - name: npm install and build
        run: |
          npm ci
          npm run build
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          TENSOR_API_URL: ${{ secrets.TENSOR_API_URL }}
          TENSOR_API_KEY: ${{ secrets.TENSOR_API_KEY }}
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          VIDU_API_KEY: ${{ secrets.VIDU_API_KEY }}
          PEXELS_API_KEY: ${{ secrets.PEXELS_API_KEY }}
          NEXT_PUBLIC_BASE_URL: ${{ secrets.NEXT_PUBLIC_BASE_URL }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NODE_ENV: production
      
      - name: Create enhanced startup script
        run: |
          cat > startup.sh << 'EOL'
          #!/bin/bash
          # TDNM App startup script for Azure Web App
          
          set -e
          
          echo "=== TDNM App Startup on Azure ==="
          echo "Starting at $(date)"
          cd /home/site/wwwroot
          echo "Current directory: $(pwd)"
          echo "Node.js version: $(node -v)"
          echo "NPM version: $(npm -v)"
          
          # Run the ffmpeg installation script if it exists
          if [ -f "scripts/install-ffmpeg.sh" ]; then
            echo "Running ffmpeg installation script..."
            chmod +x scripts/install-ffmpeg.sh
            ./scripts/install-ffmpeg.sh
          else
            echo "ffmpeg installation script not found, installing manually..."
            
            # Function to check if a command exists
            command_exists() {
              command -v "$1" >/dev/null 2>&1
            }
            
            # Install ffmpeg if not already installed
            if ! command_exists ffmpeg; then
              echo "Installing ffmpeg..."
              apt-get update -y
              apt-get install -y ffmpeg
              echo "ffmpeg installed successfully: $(ffmpeg -version | head -n 1)"
            else
              echo "ffmpeg is already installed: $(ffmpeg -version | head -n 1)"
            fi
            
            # Create necessary directories for generated content
            echo "Creating directories for generated content..."
            mkdir -p public/generated-audios
            mkdir -p public/generated-images
            mkdir -p public/generated-videos
            mkdir -p tmp
            chmod -R 755 public
            chmod -R 755 tmp
          fi
          
          # Run health check to verify environment
          echo "Running environment health check..."
          node -e "const { execSync } = require('child_process'); try { console.log(execSync('ffmpeg -version').toString().split('\n')[0]); console.log('Environment check passed!'); } catch(e) { console.error('Environment check failed:', e.message); }"
          
          # Start the application
          echo "Starting application at $(date)..."
          exec npm start
          EOL
          
          chmod +x startup.sh
      
      - name: Create web.config for IIS
        run: |
          cat > web.config << 'EOL'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <system.webServer>
              <handlers>
                <add name="iisnode" path="server.js" verb="*" modules="iisnode" />
              </handlers>
              <rewrite>
                <rules>
                  <rule name="myapp">
                    <match url="/*" />
                    <action type="Rewrite" url="server.js" />
                  </rule>
                </rules>
              </rewrite>
              <iisnode watchedFiles="web.config;*.js" nodeProcessCommandLine="%ProgramFiles%\nodejs\node.exe" />
              <security>
                <requestFiltering>
                  <requestLimits maxAllowedContentLength="104857600" /> <!-- 100MB in bytes -->
                </requestFiltering>
              </security>
            </system.webServer>
          </configuration>
          EOL
      
      - name: Create .env file for production
        run: |
          cat > .env.production << 'EOL'
          # This file will be included in the deployment package
          # But actual values will be taken from environment variables
          OPENAI_API_KEY=
          OPENROUTER_API_KEY=
          TENSOR_API_URL=
          TENSOR_API_KEY=
          HF_TOKEN=
          GEMINI_API_KEY=
          VIDU_API_KEY=
          PEXELS_API_KEY=
          NEXT_PUBLIC_BASE_URL=
          GROQ_API_KEY=
          DATABASE_URL=
          NODE_ENV=production
          EOL
      
      - name: Create verification script
        run: |
          cat > scripts/verify-deployment.js << 'EOL'
          /**
           * Deployment verification script for TDNM App
           * Run this script after deploying to verify that the environment is correctly set up
           */
          
          const https = require('https');
          const http = require('http');
          const { URL } = require('url');
          
          // Configuration
          const config = {
            // Set your deployed application URL here
            baseUrl: process.env.VERIFY_URL || 'http://localhost:3000',
            // Endpoints to test
            endpoints: [
              { path: '/api/health', method: 'GET', name: 'Health Check' },
              { path: '/api/deployment-test', method: 'GET', name: 'Deployment Test' }
            ],
            // Timeout in milliseconds
            timeout: 30000
          };
          
          /**
           * Make an HTTP request to the specified URL
           * @param {string} url - The URL to request
           * @param {string} method - The HTTP method to use
           * @returns {Promise<Object>} - The response data
           */
          function makeRequest(url, method = 'GET') {
            return new Promise((resolve, reject) => {
              const parsedUrl = new URL(url);
              const options = {
                hostname: parsedUrl.hostname,
                port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
                path: parsedUrl.pathname + parsedUrl.search,
                method: method,
                timeout: config.timeout,
                headers: {
                  'User-Agent': 'TDNM-Deployment-Verification/1.0'
                }
              };
          
              const client = parsedUrl.protocol === 'https:' ? https : http;
              
              const req = client.request(options, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                  data += chunk;
                });
                
                res.on('end', () => {
                  try {
                    const jsonData = JSON.parse(data);
                    resolve({
                      statusCode: res.statusCode,
                      headers: res.headers,
                      data: jsonData
                    });
                  } catch (error) {
                    resolve({
                      statusCode: res.statusCode,
                      headers: res.headers,
                      data: data,
                      error: 'Failed to parse JSON response'
                    });
                  }
                });
              });
              
              req.on('error', (error) => {
                reject(error);
              });
              
              req.on('timeout', () => {
                req.destroy();
                reject(new Error(`Request timeout after ${config.timeout}ms`));
              });
              
              req.end();
            });
          }
          
          /**
           * Run all verification tests
           */
          async function runVerification() {
            console.log(`\n=== TDNM App Deployment Verification ===`);
            console.log(`Base URL: ${config.baseUrl}`);
            console.log(`Time: ${new Date().toISOString()}`);
            console.log(`===========================================\n`);
            
            let allTestsPassed = true;
            
            for (const endpoint of config.endpoints) {
              const url = `${config.baseUrl}${endpoint.path}`;
              console.log(`Testing ${endpoint.name}: ${url}`);
              
              try {
                const response = await makeRequest(url, endpoint.method);
                
                if (response.statusCode >= 200 && response.statusCode < 300) {
                  console.log(`✅ ${endpoint.name}: Success (${response.statusCode})`);
                  
                  if (endpoint.path === '/api/deployment-test') {
                    // Print detailed results for deployment test
                    console.log('\n--- Deployment Test Details ---');
                    
                    if (response.data.details) {
                      const details = response.data.details;
                      
                      // Environment info
                      console.log(`Environment: ${details.environment}`);
                      console.log(`Platform: ${details.platform}`);
                      console.log(`Node.js: ${details.nodejs}`);
                      
                      // FFmpeg test
                      if (details.tests.ffmpeg) {
                        const ffmpegTest = details.tests.ffmpeg;
                        if (ffmpegTest.success) {
                          console.log(`✅ FFmpeg: Installed at ${ffmpegTest.path}`);
                          console.log(`   Version: ${ffmpegTest.version}`);
                        } else {
                          console.log(`❌ FFmpeg: Not installed or not found in PATH`);
                          console.log(`   Error: ${ffmpegTest.error || ffmpegTest.message}`);
                          allTestsPassed = false;
                        }
                      }
                      
                      // Directories test
                      if (details.tests.directories) {
                        console.log('\nDirectory Access:');
                        for (const [dirName, dirResult] of Object.entries(details.tests.directories)) {
                          if (dirResult.success) {
                            console.log(`✅ ${dirName}: Exists and writable`);
                          } else {
                            console.log(`❌ ${dirName}: ${dirResult.error}`);
                            allTestsPassed = false;
                          }
                        }
                      }
                      
                      // Environment variables test
                      if (details.tests.environmentVariables) {
                        console.log('\nEnvironment Variables:');
                        for (const [envName, envResult] of Object.entries(details.tests.environmentVariables)) {
                          if (envResult.success) {
                            console.log(`✅ ${envName}: Configured`);
                          } else {
                            console.log(`❌ ${envName}: Missing`);
                            allTestsPassed = false;
                          }
                        }
                      }
                      
                      // FFmpeg operation test
                      if (details.tests.ffmpegOperation) {
                        const opTest = details.tests.ffmpegOperation;
                        if (opTest.success) {
                          console.log(`\n✅ FFmpeg Operation: ${opTest.message}`);
                        } else {
                          console.log(`\n❌ FFmpeg Operation: Failed`);
                          console.log(`   Error: ${opTest.error}`);
                          allTestsPassed = false;
                        }
                      }
                    }
                    
                    console.log('-------------------------------\n');
                  }
                } else {
                  console.log(`❌ ${endpoint.name}: Failed (${response.statusCode})`);
                  console.log(`Response: ${JSON.stringify(response.data, null, 2)}`);
                  allTestsPassed = false;
                }
              } catch (error) {
                console.log(`❌ ${endpoint.name}: Error - ${error.message}`);
                allTestsPassed = false;
              }
              
              console.log(''); // Add a blank line between tests
            }
            
            // Final summary
            console.log('=== Verification Summary ===');
            if (allTestsPassed) {
              console.log('✅ All tests passed! Your deployment appears to be working correctly.');
            } else {
              console.log('❌ Some tests failed. Please check the details above and fix any issues.');
            }
            console.log('=============================\n');
          }
          
          // Run the verification
          runVerification().catch(error => {
            console.error('Verification failed with error:', error);
            process.exit(1);
          });
          EOL
          
          chmod +x scripts/verify-deployment.js
      
      - name: Zip artifact for deployment
        run: zip -r release.zip . -x "node_modules/*" ".git/*" ".github/*" "*.env" "!.env.production"
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: node-app
          path: release.zip

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: node-app
      
      - name: 'Deploy to Azure Web App'
        uses: azure/webapps-deploy@v3
        id: deploy-to-webapp
        with:
          app-name: 'videofactory'
          slot-name: 'Production'
          package: node-app
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_20FD8F6F7C40437CB2B549909CE95E02 }}
